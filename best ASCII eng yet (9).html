<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Live ASCII Video Player (DOS Colors Pro)</title>
  <style>
    :root{
      --bg:#0b0b0b; --fg:#eaeaea; --muted:#9aa0a6; --accent:#8ab4f8;
      --card:#151515; --border:#262626; --danger:#e57373;
      --stage-ar: 16/9;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
    .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100dvh;}
    header{padding:16px 20px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    header h1{font-size:18px;line-height:1.2;margin:0;font-weight:700;letter-spacing:.2px}
    header .sub{font-size:12px;color:var(--muted)}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px}
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
    input[type="text"], input[type="number"], input[type="url"], .btn, select{
      background:#101010;border:1px solid var(--border);color:var(--fg);
      padding:8px 10px;border-radius:10px;outline:none;min-width:0;
    }
    input[type="range"]{width:160px}
    .btn{cursor:pointer;user-select:none;transition:transform .05s ease, background .2s ease}
    .btn:hover{background:#141414}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:var(--accent);color:#0b1220;border-color:#2b63d3}
    .btn.danger{background:var(--danger);color:#190a0a;border-color:#7a2e2e}
    .btn.ghost{background:transparent;border-color:var(--border)}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:end}
    .grow{flex:1 1 auto}
    main{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px;min-height:0}
    .left{min-width:260px}
    .right{display:grid;grid-template-rows:1fr auto;min-height:0}
    .stage{position:relative;display:flex;align-items:center;justify-content:center;background:#000;border-radius:12px;border:1px solid var(--border);min-height:320px;overflow:auto;aspect-ratio:var(--stage-ar)}
    canvas#ascii{display:block;width:100%;height:100%;}
    .footer{padding:10px 16px;border-top:1px solid var(--border);display:flex;justify-content:space-between;color:var(--muted);font-size:12px}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:8px 12px;align-items:center}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .hint{font-size:12px;color:var(--muted);margin-top:6px}
    .stack{display:grid;gap:10px}
    .hidden{display:none !important}
    .switch{display:flex;align-items:center;gap:8px}
    .notice{background:#0f1a2b;border:1px dashed #2b63d3;color:#bcd3ff;padding:10px 12px;border-radius:12px;font-size:12px}
    .code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}

    .mobile-only{display:none}
    .desktop-only{display:initial}
    body.is-mobile .desktop-only{display:none}
    body.is-mobile .mobile-only{display:initial}

    body.is-mobile main{grid-template-columns:1fr; padding:10px; gap:10px}
    body.is-mobile .left{order:2}
    body.is-mobile .right{order:1}
    body.is-mobile .stage{min-height:38dvh; border-radius:10px}
    body.is-mobile input[type="range"]{width:100%}
    body.is-mobile .kv{grid-template-columns:1fr 1fr}
    .mobilebar{display:none}
    body.is-mobile .mobilebar{
      position:sticky;bottom:0;left:0;right:0;
      display:flex;gap:8px;align-items:center;justify-content:space-between;
      background:var(--card);border-top:1px solid var(--border);
      padding:8px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left);
      z-index:10;
    }
    body.is-mobile .mobilebar .btn{flex:0 0 auto; padding:10px 12px; border-radius:12px}
    body.is-mobile .mobilebar .btn.wide{flex:1 1 auto}
    body.is-mobile .mobilebar input[type="range"]{width:100%}
    body.is-mobile .footer{padding-bottom:calc(10px + env(safe-area-inset-bottom))}
  
/* --- Non-overlap hotfix (minimal) --- */

/* Ensure grid columns don't overflow each other */
main{min-height:0;}
.left{min-width:0; position:relative; z-index:3;}
.right{min-width:0; position:relative; z-index:1;}

/* Make cards and header sit above the stage */
.card{position:relative; z-index:2;}
header{position:relative; z-index:4;}

/* Keep the player surfaces beneath the UI */
.stage{position:relative; z-index:0;}
canvas#ascii, pre#asciiPre, video#video{position:relative; z-index:0; display:block;}
video#video{max-width:100%; height:auto;}

</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Live ASCII Video Player</h1>
        <div class="sub">DOS 16-color palette with higher fidelity (half blocks, ordered dithering, optional auto VGA palette) and performance tweaks.</div>
      </div>
      <div class="controls desktop-only">
        <button class="btn primary" id="playBtn">Play</button>
        <button class="btn ghost" id="pauseBtn">Pause</button>
        <button class="btn danger" id="stopBtn">Stop</button>
        <button class="btn ghost" id="muteBtn">Mute</button>
        <button class="btn ghost" id="fsBtn">Full-screen</button>
      </div>
    </header>

    <main>
      <section class="right">
        <div class="stage" id="stage">
          <canvas id="ascii"></canvas>
          <pre id="asciiPre" class="hidden" style="margin:0;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;line-height:1.0;font-size:14px;color:#fff;white-space:pre;user-select:text;"></pre>
        </div>
        <div class="card" style="margin-top:12px">
          <video id="video" class="hidden" crossorigin="anonymous" playsinline webkit-playsinline></video>
          <div class="small muted">The native &lt;video&gt; element is hidden by default; enable “Show native video controls” to reveal it.</div>
        </div>
      </section>

      <section class="left stack">
        <div class="card">
          <div class="row">
            <div class="grow">
              <label for="fileInput">Load video file</label>
              <input id="fileInput" type="file" accept="video/*"/>
              <div class="hint">Best: a local <span class="code">.mp4</span> (no CORS issues).</div>
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div class="grow">
              <label for="urlInput">Or paste a direct video URL</label>
              <input id="urlInput" type="url" placeholder="https://example.com/video.mp4 (must allow CORS)"/>
            </div>
            <button class="btn" id="loadUrlBtn">Load URL</button>
          </div>
        </div>

        <div class="card desktop-only">
          <div class="row">
            <div>
              <label for="scale">Sampling (px / char)</label>
              <input id="scale" type="range" min="4" max="28" step="1" value="10"/>
              <div class="small muted" id="scaleLabel">10 px/char</div>
            </div>
            <div>
              <label for="fontSize">Font size (px)</label>
              <input id="fontSize" type="number" min="6" max="28" value="14"/>
            </div>
            <div>
              <label for="fpsCap">FPS cap</label>
              <input id="fpsCap" type="number" min="5" max="60" value="30"/>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="grow">
              <label for="charset">Custom charset (dark → light)</label>
              <input id="charset" type="text" value="@$B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\&quot;^`'. " />
              <div class="hint">Tip: keep a trailing space for the lightest shade.</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="grow">
              <label for="charsetPreset">Preset</label>
              <select id="charsetPreset">
                <option value="dense" selected>Dense (classic art)</option>
                <option value="classic">Classic (@%#*+=-:. )</option>
                <option value="blocks">Blocks (█▓▒░…)</option>
                <option value="numbers">Numbers & punctuation</option>
                <option value="custom">Use Custom</option>
              </select>
            </div>
            <div class="switch">
              <input id="invert" type="checkbox"/>
              <label for="invert">Invert</label>
            </div>
            <div class="switch">
              <input id="hqLuma" type="checkbox"/>
              <label for="hqLuma">HQ luminance</label>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="grow">
              <label for="colorMode">Color mode</label>
              <select id="colorMode">
                <option value="off">Off (monochrome)</option>
                <option value="fg16" selected>DOS FG 16 (black BG)</option>
                <option value="fg16bg8">DOS FG 16 + BG 8</option>
                <option value="gray4">Grays (Black/DkGray/LtGray/White)</option>
              </select>
            </div>
            <div class="grow">
              <label for="paletteMode">Palette</label>
              <select id="paletteMode"><option value="dos" selected>Default DOS RGBI</option>

                <option value="vga-auto">VGA Auto (learn 16)</option>
                <option value="winvga16">Windows VGA 16 (Win9x)</option>

                <option value="cga16">CGA 16</option>
                <option value="win98">Windows 98</option>
                <option value="xterm16">XTerm 16</option>
                <option value="gray16">Gray 16</option>
                <option value="websafe216">Web‑safe 216 (late 90s)</option>
              </select>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="grow">
              <label for="dither">Ordered dither</label>
              <select id="dither">
                <option value="off" selected>Off</option>
                <option value="bayer2">Bayer 2×2</option>
                <option value="bayer4">Bayer 4×4</option>
              </select>
            </div>
            <div class="switch">
              <input id="halfBlock" type="checkbox"/>
              <label for="halfBlock">Half-block mode (▀/▄)</label>
            </div>
            <div class="switch">
              <input id="blink" type="checkbox"/>
              <label for="blink">Simulate blink</label>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="switch">
              <input id="showNative" type="checkbox"/>
              <label for="showNative">Show native video controls</label>
            </div>
            <div class="switch">
              <input id="usePre" type="checkbox"/>
              <label for="usePre">Render as DOM text (&lt;pre&gt;)</label>
            </div>
          </div>
        </div>

        <!-- Mobile settings collapsible -->
        <details class="settings mobile-only">
          <summary>Settings</summary>
          <div class="content">
            <div class="card" style="margin-top:6px">
              <div class="row">
                <div class="grow">
                  <label for="scale_m">Sampling (px / char)</label>
                  <input id="scale_m" type="range" min="4" max="28" step="1" value="12"/>
                  <div class="small muted" id="scaleLabel_m">12 px/char</div>
                </div>
              </div>
              <div class="row" style="margin-top:10px">
                <div style="min-width:120px">
                  <label for="fontSize_m">Font size (px)</label>
                  <input id="fontSize_m" type="number" min="6" max="24" value="12"/>
                </div>
                <div style="min-width:120px">
                  <label for="fpsCap_m">FPS cap</label>
                  <input id="fpsCap_m" type="number" min="5" max="60" value="30"/>
                </div>
              </div>
              <div class="row" style="margin-top:10px">
                <div class="grow">
                  <label for="charset_m">Custom charset (dark → light)</label>
                  <input id="charset_m" type="text" value="@$B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\&quot;^`'. " />
                </div>
                <div class="switch">
                  <input id="invert_m" type="checkbox"/>
                  <label for="invert_m">Invert</label>
                </div>
              </div>
              <div class="row" style="margin-top:10px">
                <div class="grow">
                  <label for="charsetPreset_m">Preset</label>
                  <select id="charsetPreset_m">
                    <option value="dense" selected>Dense (classic art)</option>
                    <option value="classic">Classic (@%#*+=-:. )</option>
                    <option value="blocks">Blocks (█▓▒░…)</option>
                    <option value="numbers">Numbers & punctuation</option>
                    <option value="custom">Use Custom</option>
                  </select>
                </div>
              </div>

              <div class="row" style="margin-top:10px">
                <div class="grow">
                  <label for="colorMode_m">Color mode</label>
                  <select id="colorMode_m">
                    <option value="off">Off (monochrome)</option>
                    <option value="fg16" selected>DOS FG 16 (black BG)</option>
                    <option value="fg16bg8">DOS FG 16 + BG 8</option>
                    <option value="gray4">Grays (Black/DkGray/LtGray/White)</option>
                  </select>
                </div>
                <div class="grow">
                  <label for="paletteMode_m">Palette</label>
                  <select id="paletteMode_m">
                    <option value="dos" selected>Default DOS RGBI</option>
                    <option value="vga-auto">VGA Auto (learn 16)</option>
                  </select>
                </div>
              </div>

              <div class="row" style="margin-top:10px">
                <div class="grow">
                  <label for="dither_m">Ordered dither</label>
                  <select id="dither_m">
                    <option value="off" selected>Off</option>
                    <option value="bayer2">Bayer 2×2</option>
                    <option value="bayer4">Bayer 4×4</option>
                  </select>
                </div>
                <div class="switch">
                  <input id="halfBlock_m" type="checkbox"/>
                  <label for="halfBlock_m">Half-block mode (▀/▄)</label>
                </div>
                <div class="switch">
                  <input id="blink_m" type="checkbox"/>
                  <label for="blink_m">Simulate blink</label>
                </div>
              </div>

              <div class="row" style="margin-top:10px">
                <div class="switch">
                  <input id="showNative_m" type="checkbox"/>
                  <label for="showNative_m">Show native video controls</label>
                </div>
                <div class="switch">
                  <input id="usePre_m" type="checkbox"/>
                  <label for="usePre_m">Render as DOM text (&lt;pre&gt;)</label>
                </div>
              </div>
            </div>
          </div>
        </details>

        <div class="card">
          <div class="kv small">
            <div class="muted">Resolution</div><div id="resOut">—</div>
            <div class="muted">Video</div><div id="infoOut">—</div>
            <div class="muted">Renderer</div><div id="rendererOut">Canvas text</div>
            <div class="muted">Timing</div><div id="timingOut">—</div>
            <div class="muted">Watchdog</div><div id="watchdogOut">—</div>
          </div>
        </div>
      </section>
    </main>

    <!-- Mobile action bar -->
    <div class="mobilebar" id="mobileBar" role="toolbar" aria-label="Playback controls">
      <button class="btn primary" id="mPlay">Play</button>
      <button class="btn ghost" id="mPause">Pause</button>
      <button class="btn danger" id="mStop">Stop</button>
      <button class="btn ghost" id="mMute">Mute</button>
      <button class="btn ghost" id="mFs" aria-label="Toggle Fullscreen">⤢</button>
    </div>

    <div class="footer">
      <div>Within DOS text-mode limits: 16 FG colors, 8 or 16 BG (blink trade-off), programmable VGA palette.</div>
      <div id="status" class="muted">Idle</div>
    </div>
  </div>

  <script>
    (() => {
      function isMobileUA(){
        const ua = navigator.userAgent || navigator.vendor || window.opera || "";
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
      }
      if (isMobileUA()) document.body.classList.add('is-mobile');

      function setStageAspectForOrientation(){
        if (!document.body.classList.contains('is-mobile')) return;
        const portrait = (screen.orientation && screen.orientation.type ? screen.orientation.type.includes('portrait') : window.innerHeight >= window.innerWidth);
        document.documentElement.style.setProperty('--stage-ar', portrait ? '9/16' : '16/9');
      }
      setStageAspectForOrientation();
      window.addEventListener('orientationchange', setStageAspectForOrientation);
      window.addEventListener('resize', setStageAspectForOrientation);

      const video = document.getElementById('video');
      const asciiCanvas = document.getElementById('ascii');
      const asciiCtx = asciiCanvas.getContext('2d');
      asciiCtx.textBaseline = 'top';
      const asciiPre = document.getElementById('asciiPre');
      const stage = document.getElementById('stage');

      const workCanvas = document.createElement('canvas');
      const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });

      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stopBtn = document.getElementById('stopBtn');
      const muteBtn = document.getElementById('muteBtn');
      const fsBtn = document.getElementById('fsBtn');

      const mPlay = document.getElementById('mPlay');
      const mPause = document.getElementById('mPause');
      const mStop = document.getElementById('mStop');
      const mMute = document.getElementById('mMute');
      const mFs = document.getElementById('mFs');

      const fileInput = document.getElementById('fileInput');
      const urlInput = document.getElementById('urlInput');
      const loadUrlBtn = document.getElementById('loadUrlBtn');

      const scaleInput = document.getElementById('scale');
      const scaleLabel = document.getElementById('scaleLabel');
      const fontSizeInput = document.getElementById('fontSize');
      const fpsCapInput = document.getElementById('fpsCap');
      const charsetInput = document.getElementById('charset');
      const charsetPreset = document.getElementById('charsetPreset');
      const invertInput = document.getElementById('invert');
      const hqLumaInput = document.getElementById('hqLuma');
      const showNativeInput = document.getElementById('showNative');
      const usePreInput = document.getElementById('usePre');
      const colorModeSel = document.getElementById('colorMode');
      const paletteModeSel = document.getElementById('paletteMode');
      const ditherSel = document.getElementById('dither');
      const halfBlockInput = document.getElementById('halfBlock');
      const blinkInput = document.getElementById('blink');

      const scaleInput_m = document.getElementById('scale_m');
      const scaleLabel_m = document.getElementById('scaleLabel_m');
      const fontSizeInput_m = document.getElementById('fontSize_m');
      const fpsCapInput_m = document.getElementById('fpsCap_m');
      const charsetInput_m = document.getElementById('charset_m');
      const charsetPreset_m = document.getElementById('charsetPreset_m');
      const invertInput_m = document.getElementById('invert_m');
      const showNativeInput_m = document.getElementById('showNative_m');
      const usePreInput_m = document.getElementById('usePre_m');
      const colorModeSel_m = document.getElementById('colorMode_m');
      const paletteModeSel_m = document.getElementById('paletteMode_m');
      const ditherSel_m = document.getElementById('dither_m');
      const halfBlockInput_m = document.getElementById('halfBlock_m');
      const blinkInput_m = document.getElementById('blink_m');

      const resOut = document.getElementById('resOut');
      const infoOut = document.getElementById('infoOut');
      const rendererOut = document.getElementById('rendererOut');
      const timingOut = document.getElementById('timingOut');
      const watchdogOut = document.getElementById('watchdogOut');
      const status = document.getElementById('status');

      // --- DOS & VGA palettes ---
      const DOS16 = [
        [0x00,0x00,0x00], [0xAA,0x00,0x00], [0x00,0xAA,0x00], [0xAA,0x55,0x00],
        [0x00,0x00,0xAA], [0xAA,0x00,0xAA], [0x00,0xAA,0xAA], [0xAA,0xAA,0xAA],
        [0x55,0x55,0x55], [0xFF,0x55,0x55], [0x55,0xFF,0x55], [0xFF,0xFF,0x55],
        [0x55,0x55,0xFF], [0xFF,0x55,0xFF], [0x55,0xFF,0xFF], [0xFF,0xFF,0xFF],
      ];
      let ACTIVE16 = DOS16.map
      // Windows Standard VGA 16 (Win9x-era), per Microsoft VGA.PAL / common system palette
      // Hex sequence from documented Windows VGA 16-color set:
      // 0:#000000,1:#800000,2:#008000,3:#808000,4:#000080,5:#800080,6:#008080,7:#c0c0c0,
      // 8:#808080,9:#ff0000,10:#00ff00,11:#ffff00,12:#0000ff,13:#ff00ff,14:#00ffff,15:#ffffff
      const WINDOWS_VGA16 = [
        [0x00,0x00,0x00],[0x80,0x00,0x00],[0x00,0x80,0x00],[0x80,0x80,0x00],
        [0x00,0x00,0x80],[0x80,0x00,0x80],[0x00,0x80,0x80],[0xC0,0xC0,0xC0],
        [0x80,0x80,0x80],[0xFF,0x00,0x00],[0x00,0xFF,0x00],[0xFF,0xFF,0x00],
        [0x00,0x00,0xFF],[0xFF,0x00,0xFF],[0x00,0xFF,0xFF],[0xFF,0xFF,0xFF],
      ];
    
      // --- Theme palettes (late-90s console/PC era) ---
    (c=>c.slice()); // will be replaced by VGA-auto

      const DOS8_BG = DOS16.slice(0,8);
      const GRAY4 = [DOS16[0], DOS16[8], DOS16[7], DOS16[15]];

      // --- Char presets ---
      const PRESETS = {
        dense: "@$B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\\\"^`'. ",
        classic: "@%#*+=-:. ",
        blocks: "█▓▒░@#W$9876543210?!;:+=-,._ ",
        numbers: "MNBH@$&80Z5S2I!;:,._ "
      };

      // Ordered dither matrices (normalized 0..1)
      const BAYER2 = [0,2,3,1].map(v=> (v+0.5)/4 );
      const BAYER4 = [
        0,  8,  2, 10,
       12,  4, 14,  6,
        3, 11,  1,  9,
       15,  7, 13,  5
      ].map(v=> (v+0.5)/16);

      // --- State ---
      let cols = 0, rows = 0;
      let sample = 10, fontSize = 14, fpsCap = 30;
      let charset = PRESETS.dense, invert = false, usingPre = false, useHQLuma = false;
      let colorMode = 'fg16', paletteMode = 'dos', dither = 'off', halfBlock = false, blinkOn = false;
      let fontMetrics = { chW: 8, lineH: 14 };
      let playing = false, rafId = null, vfcHandle = null, lastFrameTime = 0, lastDrawAt = 0, firstLoad = true, stallCount = 0;

      // LUTs
      let charIdxLUT = new Uint8Array(256); // 0..255 -> charset index
      function rebuildCharLUT(){
        const gl = charset.length - 1;
        for (let i=0;i<256;i++){
          charIdxLUT[i] = Math.min(gl, (i*gl/255)|0);
        }
      }

      function setStatus(s){ status.textContent = s; }
      function ms(){ return performance.now(); }
      const lumFast = (r,g,b)=> ((r*77 + g*150 + b*29) >> 8);
      const lumHQ = (r,g,b)=> (0.2126*r + 0.7152*g + 0.0722*b);
      let luminance = lumFast;

      // nearest color using squared distance in RGB (fast & good enough for DOS palette)
      function nearestIdx(rgb, palette){
        let best = 0, bestd = 1e9;
        for (let i=0;i<palette.length;i++){
          const p = palette[i];
          const dr = rgb[0]-p[0], dg = rgb[1]-p[1], db = rgb[2]-p[2];
          const d = dr*dr + dg*dg + db*db;
          if (d<bestd){ bestd=d; best=i; }
        }
        return best;
      }
      const rgbHex = rgb => "#" + [rgb[0],rgb[1],rgb[2]].map(v=>v.toString(16).padStart(2,'0')).join('');

      function mobileMode(){ return document.body.classList.contains('is-mobile'); }
      function syncMirrors(fromMobile){
        const pairs = [
          [scaleInput, scaleInput_m], [fontSizeInput, fontSizeInput_m], [fpsCapInput, fpsCapInput_m],
          [charsetInput, charsetInput_m], [charsetPreset, charsetPreset_m],
          [invertInput, invertInput_m], [showNativeInput, showNativeInput_m], [usePreInput, usePreInput_m],
          [colorModeSel, colorModeSel_m], [paletteModeSel, paletteModeSel_m], [ditherSel, ditherSel_m],
          [halfBlockInput, halfBlockInput_m], [blinkInput, blinkInput_m]
        ];
        for (const [d,m] of pairs){
          if (!d || !m) continue;
          if (fromMobile){ d.value = m.value; if (d.type==='checkbox') d.checked = m.checked; }
          else { m.value = d.value; if (m.type==='checkbox') m.checked = d.checked; }
        }
      }

      function pickCharset(){
        const useMobile = mobileMode();
        const presetEl = useMobile ? charsetPreset_m : charsetPreset;
        const customEl = useMobile ? charsetInput_m : charsetInput;
        const preset = (presetEl && presetEl.value) || 'dense';
        if (preset === 'custom'){
          let v = (customEl && customEl.value) || PRESETS.dense;
          if (v.length < 2) v = PRESETS.classic + " ";
          return v;
        }
        return PRESETS[preset] || PRESETS.dense;
      }

      function measureFont(){
        asciiCtx.font = fontSize + "px ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace";
        const m = asciiCtx.measureText("M");
        const chW = Math.max(1, Math.ceil(m.width));
        const lineH = Math.ceil((m.actualBoundingBoxAscent||fontSize*0.8) + (m.actualBoundingBoxDescent||fontSize*0.2));
        fontMetrics = { chW, lineH };
        return fontMetrics;
      }

      function updateDerived(){
        const useMobile = mobileMode();
        if (useMobile) syncMirrors(false);

        const scaleEl = useMobile ? scaleInput_m : scaleInput;
        const fontEl  = useMobile ? fontSizeInput_m : fontSizeInput;
        const fpsEl   = useMobile ? fpsCapInput_m : fpsCapInput;
        const invertEl= useMobile ? invertInput_m : invertInput;
        const showEl  = useMobile ? showNativeInput_m : showNativeInput;
        const preEl   = useMobile ? usePreInput_m : usePreInput;
        const colorEl = useMobile ? colorModeSel_m : colorModeSel;
        const palEl   = useMobile ? paletteModeSel_m : paletteModeSel;
        const dithEl  = useMobile ? ditherSel_m : ditherSel;
        const halfEl  = useMobile ? halfBlockInput_m : halfBlockInput;
        const blinkEl = useMobile ? blinkInput_m : blinkInput;

        sample = parseInt(scaleEl?.value || 10,10);
        fontSize = parseInt(fontEl?.value || 14,10);
        fpsCap = parseInt(fpsEl?.value || 30,10);
        charset = pickCharset();
        invert = !!(invertEl?.checked);
        usingPre = !!(preEl?.checked);
        colorMode = (colorEl?.value) || 'fg16';
        paletteMode = (palEl?.value) || 'dos';
        dither = (dithEl?.value) || 'off';
        halfBlock = !!(halfEl?.checked);
        blinkOn = !!(blinkEl?.checked);
        useHQLuma = !!(hqLumaInput?.checked);
        luminance = useHQLuma ? lumHQ : lumFast;

        if (scaleLabel) scaleLabel.textContent = sample + ' px/char';
        if (scaleLabel_m) scaleLabel_m.textContent = sample + ' px/char';

        rebuildCharLUT();

        if (video.videoWidth && video.videoHeight){
          const { chW, lineH } = measureFont();
          const charAspect = lineH / chW;
          const vH = halfBlock ? (video.videoHeight/2)|0 : video.videoHeight;
          cols = Math.max(1, Math.floor(video.videoWidth / sample));
          rows = Math.max(1, Math.floor(vH / sample * charAspect));
          workCanvas.width = cols;
          workCanvas.height = halfBlock ? rows*2 : rows;
          asciiCanvas.width = chW * cols;
          asciiCanvas.height = lineH * rows;
          resOut.textContent = cols + " × " + rows + (halfBlock ? " (half-block x2 vertically)" : "") + " chars";
          infoOut.textContent = video.videoWidth + "×" + video.videoHeight + " @ " + (video.frameRate || '?') + "fps";
          rendererOut.textContent = usingPre ? 'DOM <pre>' : 'Canvas text';
        }

        asciiPre.classList.toggle('hidden', !usingPre);
        asciiCanvas.classList.toggle('hidden', usingPre);
        video.classList.toggle('hidden', !(showEl?.checked));
      }

      // --- VGA Auto palette (learn 16 colors from incoming frames) ---
      // Lightweight K-Means on sampled pixels; run for a few iterations on first frames, then freeze
      let autoPaletteActive = false;
      let km = null;
      function kmeansInit(k){ return { k, centers: [], counts: new Uint32Array(k), sums: Array.from({length:k}, ()=>[0,0,0]), warmed:false, frames:0 }; }
      function kmeansAddSamples(km, data, step){
        // sample ~ (cols*rows)/step pixels for speed
        for (let i=0;i<data.length; i+=4*step){
          km.centers.length || km.centers.push([data[i],data[i+1],data[i+2]]);
        }
      }
      function kmeansIterate(km, data, iters=2, sampleStep=8){
        if (km.centers.length===0){
          // seed with 16 dispersed colors from DOS16 as a start
          km.centers = DOS16.map(c=>c.slice(0));
        }
        for (let it=0; it<iters; it++){
          km.counts.fill(0); for (let j=0;j<km.k;j++){ km.sums[j][0]=km.sums[j][1]=km.sums[j][2]=0; }
          for (let i=0;i<data.length; i+=4*sampleStep){
            const r=data[i], g=data[i+1], b=data[i+2];
            let best=0, bestd=1e9;
            for (let c=0;c<km.k;c++){
              const cc=km.centers[c]; const dr=r-cc[0], dg=g-cc[1], db=b-cc[2];
              const d=dr*dr+dg*dg+db*db;
              if (d<bestd){bestd=d;best=c;}
            }
            km.counts[best]++; km.sums[best][0]+=r; km.sums[best][1]+=g; km.sums[best][2]+=b;
          }
          for (let c=0;c<km.k;c++){
            const cnt=km.counts[c]||1; km.centers[c][0]=(km.sums[c][0]/cnt)|0; km.centers[c][1]=(km.sums[c][1]/cnt)|0; km.centers[c][2]=(km.sums[c][2]/cnt)|0;
          }
        }
        ACTIVE16 = km.centers.map(c=>[c[0]&0xFC, c[1]&0xFC, c[2]&0xFC]).slice(0,16); // snap to 6-bit VGA DAC grid
      }

      // Dither helpers
      function bayerVal(x,y){
        if (dither==='bayer2'){ return BAYER2[(y&1)*2 + (x&1)]; }
        if (dither==='bayer4'){ return BAYER4[(y&3)*4 + (x&3)]; }
        return 0.0;
      }

      function drawFrame(){
        if (!video.videoWidth || !video.videoHeight) return;
        try {
          workCtx.drawImage(video, 0, 0, workCanvas.width, workCanvas.height);
        } catch (e){ setStatus('⚠️ Draw blocked (likely CORS). Load a local file instead.'); stopLoops(); return; }

        const img = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
        const data = img.data;

        // VGA auto palette learning for first ~2 seconds of playback or until stabilized
        if (paletteMode==='vga-auto'){
          if (!km) km = kmeansInit(16);
          if (km.frames < 60){ // learn for first frames
            kmeansIterate(km, data, 1, 16);
            km.frames++;
          }
        } else if (paletteMode==='n64-16'){ ACTIVE16 = N64_16.map(c=>c.slice()); }
        else if (paletteMode==='win98-16'){ ACTIVE16 = WIN98_16.map(c=>c.slice()); }
        else if (paletteMode==='websafe-16'){ ACTIVE16 = WEBSAFE_16.map(c=>c.slice()); }
        else if (paletteMode==='winvga16'){ ACTIVE16 = WINDOWS_VGA16.map(c=>c.slice()); }
        else {
          ACTIVE16 = DOS16.map(c=>c.slice());
        }

        const grad = charset, gl = grad.length - 1, inv = invert;
        const ctx = asciiCtx;
        ctx.save();
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);
        ctx.font = fontSize + "px ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace";

        const chW = fontMetrics.chW, lineH = fontMetrics.lineH;
        if (blinkOn){ /* simple blink via alternating frame flag */ }

        if (usingPre){
          // DOM <pre> path (monochrome only for speed)
          let out = new Array(rows);
          for (let y=0; y<rows; y++){
            const chars = new Array(cols);
            for (let x=0; x<cols; x++){
              let p = ((y* (halfBlock?2:1)) * cols + x) * 4;
              const r=data[p], g=data[p+1], b=data[p+2];
              let Y = luminance(r,g,b);
              // Ordered dither on luminance
              const dth = bayerVal(x,y) * 255;
              Y = Math.max(0, Math.min(255, Y + (dither==='off'?0: (Y<128? -dth : dth) )));
              let idx = charIdxLUT[Y];
              if (inv) idx = gl-idx;
              chars[x] = grad[idx];
            }
            out[y] = chars.join('');
          }
          asciiPre.textContent = out.join('\n');
        } else {
          // Canvas path (color & mono)
          if (!halfBlock){
            for (let y = 0; y < rows; y++){
              // Build runs per row for fewer fillStyle changes
              let runColor = null, runStart = 0, runText = [];
              for (let x = 0; x < cols; x++){
                const p = (y * cols + x) * 4;
                const r=data[p], g=data[p+1], b=data[p+2];
                let Y = luminance(r,g,b);
                // Ordered dither on luminance to pick char
                const dth = bayerVal(x,y) * 255;
                Y = Math.max(0, Math.min(255, Y + (dither==='off'?0: (Y<128? -dth : dth) )));
                let idx = charIdxLUT[Y];
                if (inv) idx = gl-idx;
                const ch = grad[idx];

                let fg = null, bg = null;
                if (colorMode==='fg16' || colorMode==='fg16bg8' || colorMode==='gray4'){
                  if (colorMode==='gray4'){ fg = GRAY4[ nearestIdx([r,g,b], GRAY4) ]; }
                  else { fg = ACTIVE16[ nearestIdx([r,g,b], ACTIVE16) ]; }
                  if (colorMode==='fg16bg8'){ bg = DOS8_BG[ nearestIdx([r,g,b], DOS8_BG) ]; }
                }

                // Background fill (only if fg16bg8 to keep perf)
                if (bg){
                  ctx.fillStyle = rgbHex(bg);
                  ctx.fillRect(x*chW, y*lineH, chW, lineH);
                }

                const colHex = colorMode==='off' ? '#fff' : rgbHex(fg||[255,255,255]);
                if (!runColor){ runColor = colHex; runStart = x; runText = [ch]; }
                else if (runColor === colHex){ runText.push(ch); }
                else {
                  ctx.fillStyle = runColor;
                  ctx.fillText(runText.join(''), runStart*chW, y*lineH);
                  runColor = colHex; runStart = x; runText = [ch];
                }
              }
              if (runText.length){
                ctx.fillStyle = runColor;
                ctx.fillText(runText.join(''), runStart*chW, y*lineH);
              }
            }
          } else {
            // Half-block mode: 2 source rows -> 1 cell using '▀' (upper half block). FG represents top color, BG represents bottom.
            const UP = "▀"; const SPACE = " ";
            for (let y = 0; y < rows; y++){
              let runFG = null, runBG = null, runStart = 0, runText = [];
              for (let x = 0; x < cols; x++){
                const pTop = ((y*2) * cols + x) * 4;
                const pBot = ((y*2+1) * cols + x) * 4;
                const rt=data[pTop], gt=data[pTop+1], bt=data[pTop+2];
                const rb=data[pBot], gb=data[pBot+1], bb=data[pBot+2];
                // choose colors per half
                const topColor = ACTIVE16[ nearestIdx([rt,gt,bt], paletteMode==='vga-auto'?ACTIVE16:DOS16) ];
                const botColor = ACTIVE16[ nearestIdx([rb,gb,bb], paletteMode==='vga-auto'?ACTIVE16:DOS16) ];
                // choose char: if same color, prefer full block; else use upper-half block glyph (▀) so BG shows bottom color
                const same = (topColor[0]===botColor[0] && topColor[1]===botColor[1] && topColor[2]===botColor[2]);
                const ch = same ? "█" : UP;

                // dither: slight bias to alternate using SPACE vs ▀ when colors very close
                const dth = bayerVal(x,y);
                const dist = Math.abs(luminance(rt,gt,bt) - luminance(rb,gb,bb));
                const charOut = (dist < 12 && dth > 0.6) ? SPACE : ch;

                // flush runs when color pair changes
                const fgHex = rgbHex(topColor);
                const bgHex = rgbHex(botColor);
                const sameRun = (runFG===fgHex && runBG===bgHex);
                if (!runText.length){ runFG = fgHex; runBG = bgHex; runStart = x; runText = [charOut]; }
                else if (sameRun){ runText.push(charOut); }
                else {
                  // draw run
                  if (runBG){
                    ctx.fillStyle = runBG;
                    ctx.fillRect(runStart*chW, y*lineH, (x-runStart)*chW, lineH);
                  }
                  ctx.fillStyle = runFG;
                  ctx.fillText(runText.join(''), runStart*chW, y*lineH);
                  runFG = fgHex; runBG = bgHex; runStart = x; runText = [charOut];
                }
              }
              if (runText.length){
                if (runBG){
                  ctx.fillStyle = runBG;
                  ctx.fillRect(runStart*chW, y*lineH, (cols-runStart)*chW, lineH);
                }
                ctx.fillStyle = runFG;
                ctx.fillText(runText.join(''), runStart*chW, y*lineH);
              }
            }
          }
        }

        ctx.restore();
        lastDrawAt = ms();
      }

      function stopLoops(){
        playing = false;
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
        if (vfcHandle) { try { video.cancelVideoFrameCallback(vfcHandle); } catch{} vfcHandle = null; }
      }

      function loopRAF(){
        if (!playing) return;
        const now = ms();
        const minDelta = 1000 / Math.max(1, fpsCap);
        if (now - lastFrameTime >= minDelta){
          drawFrame();
          lastFrameTime = now;
          timingOut.textContent = 'rAF';
        }
        rafId = requestAnimationFrame(loopRAF);
      }
      function loopVFC(){
        if (!playing) return;
        drawFrame();
        timingOut.textContent = 'video.requestVideoFrameCallback';
        vfcHandle = video.requestVideoFrameCallback(loopVFC);
      }
      function startLoops(){
        stopLoops();
        playing = true;
        lastFrameTime = 0;
        lastDrawAt = ms();
        if (typeof video.requestVideoFrameCallback === 'function'){ vfcHandle = video.requestVideoFrameCallback(loopVFC); }
        else { rafId = requestAnimationFrame(loopRAF); }
      }

      const WATCHDOG_INTERVAL_MS = 2000, FREEZE_THRESHOLD_MS = 2500;
      setInterval(() => {
        if (!playing) return;
        const now = ms();
        if (now - lastDrawAt > FREEZE_THRESHOLD_MS){
          console.warn('[ASCII Watchdog] Freeze detected. Attempting recovery...');
          stallCount++;
          document.getElementById('watchdogOut').textContent = 'Recoveries: ' + stallCount;
          setStatus('Recovering from stall…');
          try {
            if (video.readyState < 2) {
              const src = video.currentSrc || video.src; const t = video.currentTime;
              video.load(); video.src = src; video.currentTime = t;
            }
            startLoops();
            if (video.paused) { video.play().catch(()=>{}); }
          } catch(e){}
          lastDrawAt = now;
        }
      }, WATCHDOG_INTERVAL_MS);
      ['stalled','suspend','waiting','emptied','error'].forEach(ev => {
        video.addEventListener(ev, () => { setStatus('Video ' + ev + '…'); startLoops(); });
      });

      // UI wiring
      const inputs = [scaleInput,fontSizeInput,fpsCapInput,charsetInput,charsetPreset,invertInput,hqLumaInput,showNativeInput,usePreInput,colorModeSel,paletteModeSel,ditherSel,halfBlockInput,blinkInput];
      inputs.forEach(el => {
        if (!el) return;
        const evt = (el.tagName==='SELECT') ? 'change' : 'input';
        el.addEventListener(evt, () => { syncMirrors(false); updateDerived(); });
      });
      const minputs = [scaleInput_m,fontSizeInput_m,fpsCapInput_m,charsetInput_m,charsetPreset_m,invertInput_m,showNativeInput_m,usePreInput_m,colorModeSel_m,paletteModeSel_m,ditherSel_m,halfBlockInput_m,blinkInput_m];
      minputs.forEach(el => {
        if (!el) return;
        const evt = (el.tagName==='SELECT') ? 'change' : 'input';
        el.addEventListener(evt, () => { syncMirrors(true); updateDerived(); });
      });
      if (scaleInput) scaleInput.addEventListener('input', () => { if (scaleLabel) scaleLabel.textContent = scaleInput.value + ' px/char'; });
      if (scaleInput_m) scaleInput_m.addEventListener('input', () => { if (scaleLabel_m) scaleLabel_m.textContent = scaleInput_m.value + ' px/char'; });
      if (charsetPreset) charsetPreset.addEventListener('change', () => { if (charsetPreset.value!=='custom') charsetInput.value = PRESETS[charsetPreset.value]; updateDerived(); });
      if (charsetPreset_m) charsetPreset_m.addEventListener('change', () => { if (charsetPreset_m.value!=='custom') charsetInput_m.value = PRESETS[charsetPreset_m.value]; syncMirrors(true); updateDerived(); });

      if (playBtn) playBtn.addEventListener('click', async () => { try { await video.play(); startLoops(); setStatus('Playing'); } catch {} });
      if (pauseBtn) pauseBtn.addEventListener('click', () => { video.pause(); stopLoops(); setStatus('Paused'); });
      if (stopBtn) stopBtn.addEventListener('click', () => { video.pause(); video.currentTime=0; stopLoops(); setStatus('Stopped'); });
      if (muteBtn) muteBtn.addEventListener('click', () => {
        video.muted = !video.muted;
        if (muteBtn) muteBtn.textContent = video.muted ? 'Unmute' : 'Mute';
        if (mMute) mMute.textContent = video.muted ? 'Unmute' : 'Mute';
      });
      if (fsBtn) fsBtn.addEventListener('click', () => {
        if (!document.fullscreenElement){ (stage.requestFullscreen && stage.requestFullscreen()); }
        else { (document.exitFullscreen && document.exitFullscreen()); }
      });

      if (mPlay) mPlay.addEventListener('click', async () => { try { await video.play(); startLoops(); setStatus('Playing'); } catch{} });
      if (mPause) mPause.addEventListener('click', () => { video.pause(); stopLoops(); setStatus('Paused'); });
      if (mStop) mStop.addEventListener('click', () => { video.pause(); video.currentTime=0; stopLoops(); setStatus('Stopped'); });
      if (mMute) mMute.addEventListener('click', () => { video.muted = !video.muted; mMute.textContent = video.muted ? 'Unmute' : 'Mute'; if (muteBtn) muteBtn.textContent = mMute.textContent; });
      if (mFs) mFs.addEventListener('click', () => {
        if (!document.fullscreenElement){ (stage.requestFullscreen && stage.requestFullscreen()); }
        else { (document.exitFullscreen && document.exitFullscreen()); }
      });

      fileInput.addEventListener('change', (e) => { const f=e.target.files?.[0]; if (f){ const url=URL.createObjectURL(f); video.src=url; video.dataset.objecturl=url; video.load(); setStatus('Loaded local file: '+f.name); } });
      function revokeObjectURLIfAny(){ if (video.dataset.objecturl){ try{URL.revokeObjectURL(video.dataset.objecturl);}catch{} delete video.dataset.objecturl; } }
      function loadUrl(url){ revokeObjectURLIfAny(); video.crossOrigin='anonymous'; video.src=url.trim(); video.load(); setStatus('Loaded URL (may require CORS): '+url); }
      loadUrlBtn.addEventListener('click', () => { const url=urlInput.value.trim(); if (url) loadUrl(url); });

      video.addEventListener('loadedmetadata', () => {
        if (firstLoad && mobileMode()){
          scaleInput_m.value = '12'; fontSizeInput_m.value='12'; fpsCapInput_m.value='30';
          charsetPreset_m.value='dense'; charsetInput_m.value=PRESETS.dense; colorModeSel_m.value='fg16';
          paletteModeSel_m.value = 'dos'; ditherSel_m.value='off'; halfBlockInput_m.checked=false;
          syncMirrors(true);
          firstLoad = false;
        }
        updateDerived();
      });
      video.addEventListener('resize', updateDerived);
      window.addEventListener('resize', updateDerived);

      video.addEventListener('pause', () => { stopLoops(); setStatus('Paused'); });
      video.addEventListener('ended', () => { stopLoops(); setStatus('Ended'); });

      stage.addEventListener('click', () => {
        if (!mobileMode()) return;
        if (video.paused){ video.play().then(()=>{ startLoops(); setStatus('Playing'); }).catch(()=>{}); }
        else { video.pause(); stopLoops(); setStatus('Paused'); }
      });

      document.addEventListener('visibilitychange', () => { if (document.hidden){ stopLoops(); } else if (!video.paused){ startLoops(); } });

      // Init
      charsetInput.value = PRESETS.dense;
      if (charsetInput_m) charsetInput_m.value = PRESETS.dense;
      updateDerived();
    })();
  </script>
</body>
</html>
